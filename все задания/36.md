# Проблема приватных свойств при наследовании в ООП в Python

То, что приватные свойства не наследуются, может привести к неожиданной проблеме. Давайте посмотрим на примере. Пусть у нас есть следующий класс-родитель с приватным свойством:

```py
class User:
	__age = 0

	def setAge(self,age):
		self.__age = age

	def getAge(self):
		return self.__age
```

Пусть в классе-потомке мы решили сделать метод, который будет увеличивать возраст на единицу. Однако, попытка изменить приватное свойство родителя приведет к ошибке:

```py
class Student(User):
  def defincAge(self):
    self.__age=self.__age+1  # ошибка
```

Ошибка исчезнет, если в классе-потомке объявить приватное

```py
class Student(User):
  __age = 0
  def defincAge(self):
    self.__age=self.__age+1  # ошибка
```

Тут-то нас и поджидает ловушка! На самом деле мы породили два приватных свойства: одно в родителе и одно в потомке. И они работают полностью независимо. Это значит, что методы родителя будут изменять свое свойство, а методы потомка - свои.

Эта проблема на самом деле имеет решение. Просто нужно манипулировать приватными свойствами родителя через методы этого родителя. Давайте перепишем наш код в соответствии с этим:

```py
class Student(User):
  __age = 0
  def __init__(self):
    __age = self.getAge()

  def defincAge(self):
    self.__age=self.__age+1

```

## Задание

1. В следущем коде в классе потомка переопределяется метод родителя. Исправьте проблемы в этом коде:

```py
class User:
	__name = ''

	def setName(self,name):
		self.__name = name

	def getName(self):
		return self.__name

class Employee(User):
	def setName(self,name):
		if (len(name) > 0):
			self.__name = name
```
